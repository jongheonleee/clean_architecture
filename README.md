# 🧼 클린 아키텍쳐

## 📌 02. 벽돌부터 시작하기 : 프로그래밍 패러다임 

### 3. 패러다임 개요

> ### 👉 셋 다 프로그래밍의 규칙에 대한 이야기

- 구조적 프로그래밍(절차지향 프로그래밍) : 제어 흐름을 직접적으로 전환
- 객체지향 프로그래밍(OOP) : 제어 흐름을 간접적으로 전환 
- 함수형 프로그래밍(FP) : 할당문에 제약


### 4. 구조적 프로그래밍(절차지향 프로그래밍)

### 5. 객체 지향 프로그래밍(OOP)

> ### 👉 소스 코드 의존성 != 제어흐름, 즉 간접적으로 제어 흐름을 전환

- oop의 핵심, 캡슐화, 상속, 추상화, 다형성
  - 캡슐화 : 데이터는 윽닉, 일부 함수만 노출
  - 상속 : 변수와 함수를 하나의 유효 범위로 묶어서 재정의
  - 다형성 : 부모 타입 참조 변수로 자식 타입 사용 
    - 코드를 특정 클래스에 의존하지 않으며 프로그래밍 -> 변경에 유리 

소스 코드 의존성 == 제어 흐름 
<img src="https://github.com/jongheonleee/clean_architecture/assets/87258372/ab8c3d72-fadf-4e3d-908d-1ed689ce4c45" width="500" height="500"/>

소스 코드 의존성 != 제어 흐름 
<img src="https://github.com/jongheonleee/clean_architecture/assets/87258372/ea492b83-d4cb-44d7-b7a6-54c2f89c95dd" width="500" height="500"/>

- 의존성 역전(다형성)
  - 호출 트리, 의존성의 방향은 반드시 제어흐름을 따름
  - 하지만, A가 B를 알고 있는데, 그 사이의 인터페이스를 배치하면 의존성이 제어흐름의 방향과 일치하지 않음
    - 런타임 시점에 인터페이스는 존재안함
    - 변경에 유리함 
    - 배포 독립성 : 컴포넌트 소스 코드 변경 -> 해당 코드가 포함된 컴포넌트만 재배포
    - 개발 독립성 : 서로 다른 팀에서 각 모듈을 독립적으로 개발 
  
- oop란?
  - 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 제어 권한을 획득할 수 있음
  - 변경에 유리하게 설계
  

### 6. 함수형 프로그래밍 

## 📌 03. 설계 원칙(SOLID)

### 1. SRP : 단일 책임 원칙, 하나의 액터에 대해 책임져야함, 즉 책임을 분리

> ### 👉 하나의 액터에 대해 책임 져야함

- 액터 : 변경을 요청하는 한명 이상의 사람
- 단일 모듈은 변경의 이유가 하나
    - 모듈 : 소스 파일(함수 + 데이터)
- 한 클래스가 여러 액터에 대해 책임지면, 그만큼 변경 요구 사항이 늘어남
- 더욱이, 서로 다른 액터가 특정 코드를 공유하게 되면 추후에 변경 사항을 적용하는 과정에서 문제가 발생함
  - 우발적 중복 -> A의 요구 사항을 충족하면 B도 변경된 사항을 적용 받음
  - 병합 -> 변경사항이 충돌하여 병합 발생



> ### 👉 서로 다른 액터는 그에 대응하는 클래스를 분리해서 관리

- 세명의 액터에 대해 책임지고 있음 
<img src="https://github.com/jongheonleee/clean_architecture/assets/87258372/678170a5-3a45-4e0a-93db-dfd1c314edd8" width="500" height="500"/>

- 그 중 두 명의 액터가 특정 알고리즘을 공유 
<img src="https://github.com/jongheonleee/clean_architecture/assets/87258372/a4e7de29-e2bb-4285-a29d-4b3caf863b55" width="500" height="500"/>

### 💥 문제 발생 
- 공유한 알고리즘의 변경 사항이 2개, 만약 한 곳에 변경 사항이 발생되었고 이를 처리한다면, 나머지 액터는 변경된 알고리즘을 사용. 즉 꼬여버릴 수 있음
- 두 명의 액터가 동시에 변경 사항이 발생함. 즉 변경 사항이 충돌되어 병합 발생

### ✅ 해결
- 서로 다른 클래스로 분리해내기 
<img src="https://github.com/jongheonleee/clean_architecture/assets/87258372/709fc478-b35c-4245-b56d-bb48ba01af9d" width="500" height="500"/>


### 2. OCP : 개방-폐쇄 원칙, 확장에는 열려 있고 변경에는 닫혀있다

> ### 👉 확장에는 열려 있고 변경에는 닫혀있음, 즉 다형성을 적극 활용한 프로그래밍. 

- 대표 예시는 Iterator 코드, chapter03 Ocp_01 코드 참고
- iterator 코드는 다형성을 활용하여 추상적으로 되어 있음, 따라서 구현체가 변경이 되어도 해당 부분은 변경되지 않음
- 아키텍쳐 수준에서도 OCP를 적용해야함
  - 다양한 디자인 패턴들은 모두 OCP 원칙을 준수하기 위해 나옴
  - 예를 들어, Template Method Pattern, Strategy, Iterator ...
  - 위의 패턴 모두 설계와 구현부를 분리해내어 OCP를 지킴
 
- OCP 대표 예시

<img width="457" alt="OCP1" src="https://github.com/jongheonleee/clean_architecture/assets/87258372/822e8e2a-2606-41ba-abd9-b96d7e78f569">



